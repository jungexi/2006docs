1   关于redis整理	
redis就是一个基于缓存的非关系型数据库，他的优点的话就是丰富的数据类型，hash，list，set，zset，String，它是支持事务的，他还有aof和rdb两种持久化方案，aof的话就是把咱们的操作都记录再日志中，每次把redis启动起来之后它就会把这个日志表中的所有命令都进行执行，而rdb的话就是镜像，再我们修改或者新增一定数据的时候它会自动进行保存这时候的镜像，我们启动redis的时候，它就会回到最近的一个镜像，它相对与aof就效率要高一些，但是容易丢失一些数据，所以一般存储一些比较重要点的数据的话还是建议用aof持久化 ，redis还是它查询是基于内存的，所以是非常的快  停顿，我们在项目中的话，一般是用它来存点热点数据，把那些访问量比较高的给存进去，用它来做一下缓存不直接访问到数据库，之后再就是用它来解决过分布式锁的问题，我当时是做一个定时发短信的任务，就是用户生日的时候发一封邮件，单个服务的时候就好好的，就是集群的时候，它到了这个时间段就一下发了好多封短信，每个集群的服务都调用了这个定时任务，这时候我们就借助了redis，通过哪个getAndSet方法取和存都是一步操作，然后就判断没值的时候就往下运行，有值的时候就直接返回，给这个key再设置个失效时间，就解决了这个问题。这时候就如果还不说话的话
然后redis的话还有三大问题，就是缓存击穿，缓存穿透，缓存雪崩，缓存击穿的话就是一个热点数据的key到了失效时间，突然就来了一大堆的请求，直接击穿了我们的redis，访问到了数据库，这样瞬间数据库压力就大了，所以为了防止这个的问题出现，我们可以写一个定时任务，当时间快到的时候给它进行续命，还可以直接就设置成永不过期，缓存穿透的话就是有人恶意访问的情况下，就一直访问你缓存和数据库都不存在的一个key，这样的话我们加这个缓存就没有任何作用了，解决方案的话就是把这个key存到redis中并赋个空值，他再进行查的话就直接返回一个空，就不会访问到数据库，之后再就是缓存雪崩，缓存雪崩的话就是某一时间大量的key失效，所有的请求都压到了数据库，也会导致数据库崩溃，解决方案的话就是尽量不要设置同一时间吧。我介绍完了
2  多线程导出
线程的实现方式的话就是实现一个Runnable接口，还有继承Thread类重写它的run方法，在里面写具体实现，在主线程中创建线程调用一个start方法就创建好了，线程的五个状态的话就是，你创建Thread的时候就是新建状态，然后调用start方法的时候就就绪状态，当cpu把时间片分配给你的时候，这个线程就是运行状态，其他线程的话就在就绪状态中排队，当你执行完就到了死亡状态，如果你没有执行完，cpu把时间片分给了别人，这时候你就会回到就绪状态，等待着cpu选到你，还有个阻塞状态的话，就是当你加锁的情况下，a线程拿到了锁，但是cou分配的时间到了，你没执行完，就会把资源锁住，这时候b线程被cpu选到了，它去执行一看被锁了，这时候b线程就会进入到阻塞状态，直到等到a线程执行完，把锁给释放了b线程才会从阻塞状态出来

我当时的话是用它做了一个poi的导出，当时一开始是正常的通过反射加自定义注解通过这个HSSFWorkbook做一个导出，但是发现效率太慢，数据过多，之后我就把每创建一个Excel就启动一个线程，然后每次查询只查一个sheet页的数据，这样确实快了很多，但是还是不完美，之后我又加了线程池，把线程数设置最大线程数，这样线程也不需要频繁的创建和销毁了，就快完成的时候了，一下载发现导出来的是个空的，之后一想，多线程是异步的，线程还没完成，主线程是不等待的，直接执行了，然后我就百度搜索解决方案，最后找到了CountDownLatch这个方法，把线程的总数给它 ，在主线程最后下载的地方调用一个await方法，这个方法就是让你等待，当CountDownLatch数量到0的时候才会执行， 然后再线程内调用countDown方法，这个就是每次执行了这个方法就会线程减一当，减到0就证明所有线程走完了，然后主线程就会执行，加了这个之后就把这个问题解决了

3  定时任务 （发邮件  发短信  会员续费）
我当时是做一个定时发短信的任务，就是用户生日的时候发一封邮件，单个服务的时候就好好的，就是集群的时候，它到了这个时间段就一下发了好多封短信，每个集群的服务都调用了这个方法，这时候我们就借助了redis，通过哪个getAndSet方法取和存都是一步操作，然后就判断没值的时候就往下运行，有值的时候就直接返回，给这个key再设置个失效时间，就解决了这个问题
4 aop日志记录
1.首先我们需要在mysql数据库设计一张t_logbean的表，里边的字段根据需求来定义，其中主要的字段有ip记录用户的本地ip地址，className记录用户请求的包路径，methodName记录用户请求的方法，userDateTime记录请求时间，还可以记录用户请求日期，请求方法是否为异常请求等等！idea实体类与mysql数据库对应
2.新建一个类型为Annotation方法名为AopAnnotation的自定义注解
使用@Target(ElementType.METHOD)用于描述方法
@Retention(RetentionPolicy.RUNTIME)可以使用反射机制读取该注解的信息
3.方法里边有一个String类型的methodInfo() default"";用于在controller记录该方法时，声明该方法名称。
4.新建一个class类使用@component注解将它交给spring进行管理
@Aspect:作用是把当前类标识为一个切面供容器读取
@Order:主要用来控制配置类的加载顺序
5.定义一个环绕通知的方法，在方法上使用@Around(e ruan de)来定义切点表达式
  在方法执行前获取当前毫秒数再定义一个Boolean类型的 a=true
  在方法抛出异常后a=false
  在方法执行完毕后 定义一个int类型的 isException（一字赛可神）=0
   if判断!a的时候isException为1，这就说明了0为正常请求，1为异常请求
   用户请求时间为方法执行前的毫秒数减去方法执行后的毫秒数，new一个logBean
 对象，将用户请求的信息存在进去，调用logbeanDao.insert()的方法实现了日志     记录的新增
6.在controller层加上@AopAnnotation注解，表示监听此方法，也就是这个方法需要日志记录！
5基于token的登陆
用户点击登录 把用户名和密码传过去 服务端接收账号密码进行判断账号是否存在，
存在的话再判断密码是否正确，如果正就使用JWT的工具类来进行数据加密 得出一个token值
把token值返回给客户端，客户端把他存到sessionstor里面，然后使用路由守卫获取
sessionstorre里面的值判断值是否为空，为空就直接跳转到登录页面，不为空直接下一步
，服务端的拦截器先获取传过来的token值判断token值是否为空，不为空在进行解密
判断解密出来是否有数据，有数据就证明用户登录过了，就放开请求，
又因为我们认证需要请求中带有token值，所有每个请求都带有token值特别繁琐，
所以我们使用请求拦截器，所有的请求，请求之前都给他加上token值，就解决了每个请求都加token值的繁琐。
6 权限管理
首先我们是如何设计表的
我们设计五张表用户表   角色表 权限表  角色权限表  用户角色表
里面角色权限表，和用户角色表，两张关联表，关联表的话是为了，我们根据用户查询他拥有的角色，然后再通过他拥有的角色查询出每个角色有什么权限，之后根据这些权限展示不同的数据

7 事务
什么是事务
事务的话就是一组具有逻辑操作单元的sql语句，要么都发生 要么都不发生

事务的四大特性
原子性   一致性    隔离性  持久性

原子性：就是事务的操作要么都发生，要么都不发生
一致性：的话就是事务必须保证数据库从一个一致性状态，到达另一个一致性状态
隔离性：两个并行的事务是互相不干扰的谁都不干扰谁的操作
持久性：事务一旦提交，对数据库的影响是持久性的，后续的事务改变不了

传播特性
就是事务的 传播范围   A事务调用A事务 然后在调用B事务 这就用到了传播特性  是公用一个事务 还是在创建一个新的事务

隔离级别 
 A事务对B事务是否有影响   A事务提交数据还没成功  B事务来访问   让不让他访问  就是根据事务来确定的 这就是隔离级别 

8  mysql优化
首先呢肯定就是先优化我们的sql语句，然后再优化我们的索引
我简单说一下sql语句的优化吧：
1.查询不要用*代替所有，具体到某些字段，比如我们只用到了两个字段，但是用*缺代表了所有
4.分页查询的优化 limit 在大数据量的情况下我们加上where条件进行查询
5.使用恰当的sql语句，尽量不要让索引失效
6.尽量避免在where子句中对字段进行null值判断
7.尽量少写子查询，用join语句代替，少写in,like,or

索引优化：
1.使用like语句的时候，我们要将%号加在后边，这样索引才能生效
2.不要在列上进行运算，这将导致索引失效而进行全表扫描
3.复合索引：在创建复合索引时应该将最常用的限制条件的列放在最左边，依次递减

索引的类型
普通索引、主键索引、唯一值索引、全文索引

mysql的存储引擎有哪些，它们的区别是什么：
有MyISAM和InnoDB两种存储引擎。
它们的区别是：
MyISAM用的是表锁，InnoDB用的是行锁。
MyISAM不支持事务处理不支持外键而InnoDB支持

9 docker
Docker是一款可以解决运行环境和配置问题的软件容器引擎，
他由三个部分组成  镜像   容器  和仓库
由于docker默认仓库是国外仓库  网速慢下载速度慢   所以改变地址为国内仓库

1镜像
docker  seach  查询指定镜像
docker images 查询仓库中的所有镜像
docker pull 下载镜像
docker rmi   删除指定镜像
2容器
docker  run  -it --name 容器名称（唯一的）   镜像（创建容器 并进入终端  一旦退出  容器结束）
docker  run  -itd --name 容器名称（唯一的）   镜像（创建容器 进入后台运行不会进行终端 （exec 进入终端）   终端退出 容器继续运行）
docker  ps    查看运行中的容器   
docker ps -a  查看所有的容器
docker rm 删除容器  容器id（名称）（运行中的容器不能删  如果想把运行中的容器也删掉  加参数 -f）
docker stop 容器id（名称） 停止容器 
docker start  容器id（名称）启动容器