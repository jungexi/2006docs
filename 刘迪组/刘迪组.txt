1   关于redis整理
redis 是一个key-value类型的缓存
读取速度非常快 读的速度能达到每秒110000次，写的速度能达到每秒81000次。
redis拥有丰富的数据类型
String类型
string数据类型就是 key-value 型   跟map相似 设置值 是：set key value  获取值是：get key

比如地区数据  我们之前地区数据是放在数据库中的  查询速度非常的慢   地区的数据是不经常发生改变的 可以一次性存入数据库中    所以我们将地区数据list转换成字符串    设置一个唯一的key  存入到数据库中  明显速度快了不止一倍。
Hash类型
hash数据类型 是一个 key file value 结构  也就是mapmap  的数据  使用于多个数据不停的插入  导出
我曾经做一个电商项目   里面有一个购物车   他保存的数据不是固定的   并且需要经常的插入 删除  所以就符合我们使用的hash类型的数据 
我们是这样使用的   每个用户拥有一个购物车  所以我就把用户的名称加一些字段  设置成这个用户唯一的key  然后 他购买的商品id设置为 field    购买的商品数据 就转成value  每次添加购物车的时候 通过用户的key  和商品的id 进行查询  看有没有加入过购物车 有的话 就将数据取出来  获取购买的数量  在   将第二次购买的数量进行相加   然后在根据商品Id 去查询商品的库存  相减 看库存够不够   如果够了 就将相加后的总购买库存保存到redis  hash数据中  如果库存不够 就返回状态码给前台   
如果没有加入过购物车就将该商品的id设置为field   数据保存为value  添加到该用户的hash数据中
同一个key   hash 的field如果相同的话 会进行覆盖的 所以不用担心  有重复数据
List类型
List 说白了就是链表（redis 使用双端链表实现的 List），是有序的，value可以重复，可以通过下标取出对应的value值，左右两边都能进行插入和删除数据。
因为list 是先进先出 所以可以用来做消息队列
Set类型
和java的set集合差不多  都是无序没有小标 不能排序
Zset类型
和java的zset集合差不多  有序有下表 可以排序
redis的操作都是原子性的   要么都发生 要么都不发生   多个操作也支持事务  也就是单线程
redis常用的有两种存储结构  rdb  和nof   

rdb是基于快照的方式来保存数据的   ，当一定时间内  规定数量的key发生变化  rdb就会进行一次快照来保存数据   每次redis重启的时候都是从快照中读取数据   性能很高  但是数据保存能力很差  如果在某一瞬间   rdb 没有拍快照  但是我保存了很多数据  这个时候服务宕机了   那么在重启以后 redis会丢失宕机时大量的没有拍快照的数据

nof 是基于日志的方式来保存数据的，每次新增一个key  他都会将数据以新增的方式保存在日志中，这样即使服务宕机最多丢失一条数据 保存数据性能很高 ，但是保存大量数据后  redis 重启后 会从nof的日志中 将这些保存的数据从新给一个一个的新增出来  这样的话性能会非常的慢 

redis 的高性能
主从复制+哨兵
在我们使用redis的时候有这样一个疑问   那就是如果配置一个redis 的话  如果他死亡了 怎么办  还怎么缓存   这个时候redis就给了我们一个解决方案 主从复制  他就是将redis 配置多台  然后通过主从来控制他们的关系    主服务器拥有读和写的能力   从服务器只有读的能力   这个时候即使其中一台宕机 一样能够提供服务  但是这个时候主服务宕机了 那么就没有了写的能力了 怎么解决   ，别急  这个时候还有哨兵呢    哨兵就是来解决主服务器宕机  无法写数据的问题     哨兵是用来监控和故障熔断机制的  他监控主机器和从机器之间的联系  默认是30秒 如果主服务器和从服务器断开连接超过30秒 那么哨兵会开启故障熔断  从从服务器中选择一个主服务器  这样服务就恢复正常了  后面主服务器恢复正常了 那么他就会变成从服务器     这个时候注意了  哨兵必须是奇数   因为他是通过选举来选出主服务器的 。

集群   不会


2  多线程导出
我们用多线程导出  使用了  线程池  注解  java反射 
首先我们自己设置每个文档要创建多少个sheet页   每个sheet页中有多少数据
第一步先查询出我们数据库中有多少数据  
第二部 通过总条数除掉设置的每个sheet页多少条数据  计算出要创建多少sheet页  先%  有余数就加一；
第三部 通过总条数除掉计算出来的总sheet页  计算出要创建多少excel文档  先%  有余数就加一；
第四步 因为我们的需求是多线程进行导出 所以 要等所有的excel文档创建完成以后在进行下一步添加到zip压缩包中  所以就用到了 coutdownlatch  来进行计算  将创建excel文档的数量作为总数量  然后 对excel的总数量进行循环遍历  因为频繁的创建和销毁线程会浪费资源  并且每次创建线程都会浪费性能  所以我用了线程池  这样每次用的时候去线程池里面取就行了 不用频繁的创建   既节约资源 还提高了性能 。
第五步 多线程中  创建excel文档  我用的xsshwork   创建完XSSHFWORK对象 然后计算出当前文档所需要的数据  limit所需要的起始值和每页条数  然后循环遍历要创建的sheet页条数    创建sheet页  第一行需要的是他们每一列字段的名称 我们用的是注解的方式  在需要导出的字段上家上一个自定义注解   然后获取查询出来数据的某一条数据 根据java反射机制来获取他上面的标识  循环遍历 设置到第一行  当excel页创建完成后 我们就可以通过zip流将excel所保存的文件夹 写入压缩包中


3  定时任务(发邮件 发短信 会员续费）
我当时是做一个定时发短信的任务，就是用户生日的时候发一封邮件，单个服务的时候就好好的，就是集群的时候，它到了这个时间段就一下发了好多封短信，每个集群的服务都调用了这个方法，这时候我们就借助了redis，通过哪个getAndSet方法取和存都是一步操作，然后就判断没值的时候就往下运行，有值的时候就直接返回，给这个key再设置个失效时间，就解决了这个问题
4 aop日志记录
1.首先我们需要在mysql数据库设计一张t_logbean的表，里边的字段根据需求来定义，其中主要的字段有ip记录用户的本地ip地址，className记录用户请求的包路径，methodName记录用户请求的方法，userDateTime记录请求时间，还可以记录用户请求日期，请求方法是否为异常请求等等！idea实体类与mysql数据库对应
2.新建一个类型为Annotation方法名为AopAnnotation的自定义注解
使用@Target(ElementType.METHOD)用于描述方法
@Retention(RetentionPolicy.RUNTIME)可以使用反射机制读取该注解的信息
3.方法里边有一个String类型的methodInfo() default"";用于在controller记录该方法时，声明该方法名称。
4.新建一个class类使用@component注解将它交给spring进行管理
@Aspect:作用是把当前类标识为一个切面供容器读取
@Order:主要用来控制配置类的加载顺序
5.定义一个环绕通知的方法，在方法上使用@Around(e ruan de)来定义切点表达式
  在方法执行前获取当前毫秒数再定义一个Boolean类型的 a=true
  在方法抛出异常后a=false
  在方法执行完毕后 定义一个int类型的 isException（一字赛可神）=0
   if判断!a的时候isException为1，这就说明了0为正常请求，1为异常请求
   用户请求时间为方法执行前的毫秒数减去方法执行后的毫秒数，new一个logBean
 对象，将用户请求的信息存在进去，调用logbeanDao.insert()的方法实现了日志     记录的新增
6.在controller层加上@AopAnnotation注解，表示监听此方法，也就是这个方法需要日志记录！




5基于token的登陆

在我们做单体架构时，登录之后的用户信息是保存在服务端session中的，每次发送请求都会自带cookie值进行验证。随着我们现在用分布式架构，session和cookie已经不适用了。而我们又想保证用户信息的安全，所以使用到了JWT进行登录验证。JWT可以理解为加密工具，在我们的用户登录成功之后，把用户对象放进去，用JWT声明token令牌，把值传到前台，这样我们每次发送请求时都自带token值，防止越权访问。我们现在后台用的就是分布式架构，通过zuul网关去验证token，zuul网关就相当于拦截器+过滤器，我们创建一个类去继承zuulFilter过滤器，重写方法，在run方法中我们通过request.getParameter获取token值，通过JWT去解密验证token，如果token为空，则用户没有进行登录，如果token值解密错误，则用户非法访问或者token值被人为改过。当然token也有失效时间，默认是30分钟，这时解密的token值可能就为空了，但能确定不是非法访问。如果认为还是不安全，我们也可以在登录成功之后用base64再进行加密。


6 权限管理
简单来说就是每个人根据每个人的权限看到的内容是不同的
具体实现是 创建五张表  表结构  表的关系  表如何查询的    然后怎么展示 来设置的
五张表有用户表   角色表 权限表  角色权限表  用户角色表
表结构就是  
用户表  账号  密码
角色表   id  和角色名称
权限表  id 和权限名称 和地址
角色权限表   角色id 和权限id
用户角色表   用户id 和角色id
查询是 用户登录以后  发送请求时把 用户的id传到后台  然后根据id查找用户的角色  在根据角色查找用户的权限  然后返回查询到的数据    权限信息以动态拼接的方式拼接到导航栏上面


7 事务

什么是事务
事务就是一组具有逻辑操作单元的sql语句，要么都发生 要么都不发生

事务的四大特性
原子性   事务是一个不可分割的工作单位 要么都发生 要么都不发生

 一致性   数据库中的数据必须从一个一致性状态到另一个一致性状态

 隔离性 两个同时运行的事务是互不干扰的   一个事务出现异常对 不能另外一个事务造成影响

持久性  数据一旦保存到数据库  那么他就是永久的   即使服务宕机  数据也不会消失

传播特性
就是事务的 传播范围   A事务调用A事务 然后在调用B事务 这就用到了传播特性  是公用一个事务 还是在创建一个新的事务

隔离级别 
 A事务对B事务是否有影响   A事务提交数据还没成功  B事务来访问   让不让他访问  就是根据事务来确定的 这就是隔离级别 
 



8  mysql优化
   分库分表   集群   主从  建索引

9 docker
Docker是一款可以解决运行环境和配置问题的软件容器引擎，
他由三个部分组成  镜像   容器  和仓库
由于docker默认仓库是国外仓库  网速慢下载速度慢   所以改变地址为国内仓库

1镜像
docker  seach  查询指定镜像
docker images 查询仓库中的所有镜像
docker pull 下载镜像
docker rmi   删除指定镜像
2容器
docker  run  -it --name 容器名称（唯一的）   镜像（创建容器 并进入终端  一旦退出  容器结束）
docker  run  -itd --name 容器名称（唯一的）   镜像（创建容器 进入后台运行不会进行终端 （exec 进入终端）   终端退出 容器继续运行）
docker  ps    查看运行中的容器   
docker ps -a  查看所有的容器
docker rm 删除容器  容器id（名称）（运行中的容器不能删  如果想把运行中的容器也删掉  加参数 -f）
docker stop 容器id（名称） 停止容器 
docker start  容器id（名称）启动容器

	   